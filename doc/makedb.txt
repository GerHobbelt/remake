See also README.makedb for general project comments. 

With steady progress, this debugger for make has gotten good enough to
be called "alpha" and good enough to make available in public.

Using the debugger I've learned something about Makefiles, those
produced by automake, and have been able to pinpoint some problems --
even if in some cases I'm still clueless as to how to get "make" or
"automake" fix them.

- - - Tutorial / tour of the debugger 

Now some sample output. One simplest thing you can do with this
version of make is get trace output which shows you what going on in a
simple summary way. To get trace output use option --trace or short
option -x. Let's start out with a real-life example - the Makefile for
this GNU make itself. When I run "make --trace" in the src directory:

I get:

  Makefile:225 Makefile.in
  Makefile:221 all
  Makefile:383 all-am
  Makefile:260 make
  Makefile:257 loadavg
  .deps/loadavg.Po:1 loadavg.o
  make: Nothing to be done for `all'.

Already I've learned something I didn't know before: in
automake-produced Makefiles, even though "all" is listed as the first
target, it often isn't the first target to trigger! It appears that
Makefile.in (actually $(srcdir)/Makefile.in of line 225 of Makefile)
is -- and don't ask me why. I imagine that as folks start using
this, the may be able to *understand* "make" better and perhaps even
write better or more efficient Makefiles.

If you want a longer trace example, try doing this the top-level
directory.  Although you'll get more output, I think you'll find this
much more comprehensible than what you'd get if you run "make -d".

But alas there is a bit going in the makefile that alas is not really
reflected by the trace above. So let's go into the debugger itself.
For this use the --debugger or -X option.

  ./make --debugger

    /remake/src/Makefile:225: Makefile.in

Let's see where we are. In particular is this *really* the top-level
target? The "where" command shows you the target call stack:

  makedb<0> where

  =>#0  Makefile.in at /remake/src/Makefile:225

  /remake/src/Makefile:225: Makefile.in

Okay, yes we are at the top-level. But now when I do a single step
command see what happens:

  makedb<1> step

  /remake/src/Makefile:260: make
  makedb<2> where

  =>#0  make at /remake/src/Makefile:260
    #1  all-am at /remake/src/Makefile:383
    #2  all at /remake/src/Makefile:221

We are at the "make" target which was triggered by the "all-am" target
which was triggered by the "all" target. The reason we didn't stop at
"all" or "all-am" is for convenience. There were no commands
associated with making those so they weren't deemed interesting to
stop at. The "make" target however does have commands to run
associated with it. To get information about the make "target" we can
use the "print" command:


  makedb<3> print make

  make: ar.o arscan.o default.o dep.o dir.o expand.o file.o function.o getopt.o getopt1.o implicit.o main.o misc.o print.o read.o remake.o remote-stub.o rule.o signame.o trace.o variable.o version.o vpath.o | commands.o dbg_cmd.o hash.o job.o
  #  Implicit rule search has not been done.
  #  Last modified 2004-06-09 20:31:56
  #  File has not been updated.
  #  commands to execute (from `Makefile', line 261):
  	@rm -f make$(EXEEXT)
	$(LINK) $(make_LDFLAGS) $(make_OBJECTS) $(make_LDADD) $(LIBS)
	

  /remake/src/Makefile:260: make

If however one really did want to stop at "all" or "all-am" one can
set a *breakpoint* on those targets. Like this: 

   makedb<4> restart
  Changing directory to /remake/src and restarting...

  /remake/src/Makefile:225: Makefile.in
  makedb<0> break all-am
  Breakpoint on target all-am set.

  /remake/src/Makefile:225: Makefile.in

  The restart command was used to restart execution since we've already
  passed considering the "all-am" target. So let's "continue" execution
  and see what happens

  makedb<0> continue

  /remake/src/Makefile:383: all-am
  makedb<1> where

  =>#0  all-am at /remake/src/Makefile:383
    #1  all at /remake/src/Makefile:221

Note that now we have stopped at this uninteresting target. What is
it? 

  /remake/src/Makefile:383: all-am
  makedb<2> print all-am

  all-am: Makefile loadavg commands.h dbg_cmd.h debug.h default.h function.h gettext.h hash.h job.h make.h print.h remake.h rule.h trace.h variable.h | make dep.h expand.h filedef.h getopt.h
  #  Phony target (prerequisite of .PHONY).
  #  Implicit rule search has not been done.
  #  File does not exist.
  #  File has not been updated.

Note that we don't have to be stopped on a target to get information
about it:

  /remake/src/Makefile:383: all-am
  makedb<3> print all

  all: all-am
  #  Phony target (prerequisite of .PHONY).
  #  Implicit rule search has not been done.
  #  File does not exist.
  #  File has not been updated.


We can also get information about GU make's variables. That is done
also with the "print" command. 

  /remake/src/Makefile:383: all-am
  makedb<4> print MAKE

  (null):0 MAKE = $(MAKE_COMMAND)

The (null):0 means this is a built-in definition. However there is
another print which does full expansion of the variables. So if I run
x (examine) instead I get: 

  (null):0 MAKE = /src/local-cvs/remake/src/./make

In fact, "examine" doesn't need a variable name, it will work with a
string. So I could type "x This is $(MAKE)" or 
"x $(bin_PROGRAMS) $(noinst_PROGRAMS)". For the latter, I get

  make loadavg

Note, no location identification is given here (since what I put in
isn't a variable).

But I can also *change* values too using either "set" or
"setq". Let's see the difference between the two. 

  makedb<5> set MAKE $(MAKE_COMMAND)
  Variable MAKE now has value '/remake/src/./make'

 /remake/src/Makefile:383: all-am

  makedb<6> setq MAKE $(MAKE_COMMAND)
  Variable MAKE now has value '$(MAKE_COMMAND)'

So with "set", the value in the expression $(MAKE_COMMAND) is expanded
before the variable definition is assigned. With "setq" the internal
variables are kept unexpanded. Which you use or want is up to you.

Note the syntax of "set" and "setq". Don't put an "=" between the
variable and the expression. That is, "set MAKE = $(MAKE_COMMAND)" gives

  Variable MAKE now has value '= /remake/src/./make'

which is probably not what you want. Down the line, I'll probably have
a better command parser.

To close the tour of the debugger I'll finish with a list of debugger
commands. 


  makedb<7> help
  Available commands are: 
  break *target*            (b):
	Set a breakpoint at a target.

  continue                  (c):
	Continue executing debugged Makefile until another breakpoint.

  delete *target*           (d):
	Delete target breakpoint.

  down [amount]             (D):
	Select and print the target this one caused to be examined.
	An argument says how many targets down to go.

  examine *string*          (x):
	Show string with internal variables references expanded. See also 
	"print".

  quit [exit-status]        (q):
	Exit make. If a numeric argument is given, it will be the exit
	status this program reports back. Otherwise exit with status 0.

  frame *n*                 (f):
	Move target frame to *n*; In contrast to "up" tor "down",
	this sets to an absolute postion. O is the top.

  help [command]            (h):
	Display list of commands (i.e. this help text.)
	with an command name, give only the help for that command.

  info [thing]              (i):
	Show the state of thing.
	If no 'thing' is specified, show everything there is to show.


  next [amount]             (n):
	alias for step.

  print {*variable*|*target*} (p):
	Show a variable definition or information about a target.
	If a variable name is given, the value is shown with the
	variable-reference names. Don't include $ before a variable 
	name. See also "examine".
	If a target name is given, information about target is printed.

  quit [exit-status]        (q):
	Exit make. If a numeric argument is given, it will be the exit
	status this program reports back. Otherwise exit with status 0.

  restart                   (R):
	Restart program.

  set {variable|basename|trace} *value* (=):
	
  set variable *var* *value*
	Set MAKE variable to value. Variable definitions
	inside VALUE are expanded before assignment occurs.

  set basename {on|off|toggle}
	set filename to show full name or basename

  set trace {on|off|toggle}
	set tracing status


  setq *variable* *value*   ("):
	Set MAKE variable to value. Variable definitions
	inside VALUE are not expanded before assignment occurs.

  shell *string*            (!):
	Execute the rest of the line as a shell.

  info [thing]              (i):
	Show the state of thing.
	If no 'thing' is specified, show everything there is to show.


  skip                      (k):
	Skip execution of next command or action.


  step [amount]             (s):
	Step execution until another stopping point is reached.
	Argument N means do this N times (or until there's another
 	reason to stop.

  where                     (T):
	Show target stack.

  write [*target*]          (w):
	writes the commands associated of a target to a file with MAKE
	variables expanded. If no target given use the current one.

  up [amount]               (u):
	Select and print target that caused this one to be examined.
	An argument says how many targets up to go.

- - - 

For those of you like myself who live inside of GNU Emacs, included in
the tarball is remake.el which uses on gud.el to provide running the
debugger inside GNU Emacs just as the way you'd do with perl, gdb, my
bash debugger. I also have a patched gud.el which contains the remake
debugger support. For front-end support such as this, I added "up" and
"down" debugger commands to position you up or down in the Makefile
source.


- - - - 

 > Have you given any thought about how to debug things like $(shell ...)
 > invocations, or eval expansions, etc. that happen during the parsing of
 > the makefiles?

Actually, sort of. there is an debug-on-error mode. In fact, there is
an optional argument on the command line to
--debugger (-X) so you could specify what level of debugging you
want. Right now I have 

   fatal - go into the debugger on a fatal error
   error - go into the debugger on an error or a fatal error
   enter - go into the debugger before any action is taken
   full  - all of the above

With this, yes, it's possible to enter the debugger on an error in
parsing. For example consider this simple Makefile:

  1: FOO=bar
  2: all: foo
  3: foo:
  4:   @echo hi > /dev/null
     ^^ spaces here

and this debugger session

  ./make --debugger=full -f bug4
  bug4:4: *** missing separator.  Stop.
  (remake) p FOO
  bug4:1 FOO = bar

  (remake) p all

  all: foo
  #  Implicit rule search has not been done.
  #  Modification time never checked.
  #  File has not been updated.

  (remake) where
                       [no call stack]

So here, the variable FOO has been entered into its symbol table. And
so has target "all" even though not much more than entering has
probably been done.

In short, what you get depends on where you've stopped and there isn't
any a priori restriction on that.

This "debugger" (like many others) is merely just a read loop to give
you selective access to the wealth of knowledge that's already inside
the program. Over the weekend I added the ability to show a target's
status. As you probably know, all the hard work was already done in a
routine called "print_file" (which I've renamed "print_target" and
made the trivial change to all it to be externally callable instead of
local only -- thanks for the routine!)

In the past, I used to get either no information, cryptic information
or on the other hand so much spewed out I had a hard time finding the
part that might be interesting. Instead with this, I can ask the
questions I think might be interesting and go on from there.

- - -

There is one cute unexpected synergy with my bash debugger
http://bashdb.sourceforge.net. I've often found the shell stuff in
Makefiles really hard to understand with the Make's variables combined
in with the shell variables. With this, I can set a breakpoint on a
target with some code in it, dump out the script part to a file, and
then run that in the bash debugger. And should I chose to fix or patch
faulty code on the fly, I can just continue with make! It might be
cool to have some debugger command automate this: write the script
commands of the current target to a temp file, and then invoke the
bash debugger on that.


